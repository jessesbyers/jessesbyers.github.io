---
layout: post
title:      "How To...Rails: Complex Associations, Nested Forms, and Form Helpers"
date:       2020-01-23 19:28:34 +0000
permalink:  how_to_rails_complex_associations_nested_forms_and_form_helpers
---


*In my [first post](https://jessesbyers.github.io/howtorailsbasiccrudrestfulroutesandhelpermethods), I used a Contact List example to illustrate basic CRUD actions in Rails. In this post, I’ll build on that example to develop more complex model associations, and build a single nested form that allows users to create instances of multiple models with the correct associations. This will rely heavily on form helper methods and custom writer methods, and we’ll look at the HTML that is generated by using these methods with our forms.*

## Building on the Contact List Example
![]https://i.imgur.com/a62xPdB.jpg)

Imagine that the User for our Contact List app is the local fire department. In addition to knowing each household’s address information, it is important to know how many pets the family has in order to make sure the pets are rescued in case of an emergency. Our more complex app will have the following models and associations:

* A **User has many Contacts** and a **Contact belongs to a User**.
* A User has a name (string data type).
* Each Contact has a name, address, phone number, and email address (all string data types).
* A **Contact has many Pets**, and a **Pet belongs to a Contact**.
* A Pet has a name and a breed (both string data types).
* To finish off the associations, a **User has many Pets, through its Contacts**

To get started, I’ll generate the User model and the Pet model, update the Contact model with new associations, and create migrations for the new models. I will also need to update my seed data to account for new models and represent the more complex relationships.

```
rails generate resource User name:string
```
```
rails generate resource Pet name:string breed:string
```

Images:  model associations, schema, seed data

## Creating a Nested Form
In my previous post, our simple Contact model included a form to create contacts, but it only included attributes for the contact itself (name, address, phone, and email). Now that we have multiple models and complex relationships, we can create a nested form, which allows us to create contacts and their pets at the same time, while maintaining the correct associations between them.

In order to do this, we will follow these steps:

1. Plan out what our params hash should look like to include attributes for multiple models
2. Write custom writers or use macros to identify each key in the new params hash
3. Use form helpers to create a form aligned to the params we want to end up with
4. Inspect the form in the browser to ensure structure is correct and params is set up correctly
5. Update the controller to accept and process the new params hash


### 1. Plan Out Params Hash
Previously, our simple new form generated a params hash that looked like this:
```
contact = {
    :name => "Jane Smith", 
    :address => "123 Pine St, New York, NY 12121", 
    :phone => "518-872-3562", 
    :email => "jane@gmail.com"
}
```


We used this params hash to create a new contact using this code in the controller:
```
	    def create
        @contact = Contact.new(contact_params(:name, :address, :phone, :email))
        @contact.save
        redirect_to contact_path(@contact)
    End
```


Before we can build our new form with fields for our new contacts pets, we need to imagine what the new hash must look like:
```
contact = {
    :user_id => 1
    :name => "Jane Smith", 
    :address => "123 Pine St, New York, NY 12121", 
    :phone => "518-872-3562", 
    :email => "jane@gmail.com",
    :pets_attributes = {
       0 => {:name => "Pepper", :breed => "Dog"}
       1 => {:name => "Snowstorm", :breed => "Cat"}
       2 => {:name => "Fawkes", :breed => "Bird"}
     }
}
```

### 2. Write custom writers or use macros to identify each key in the new params hash
ActiveRecord has already given us reader and writer methods for most of the keys in our hash (name, address, phone, email, and pets). However, we do not have a writer method for pets_attributes. There are two ways to create this method, which will allow us to access this variable in the form and in our controller.

#### Macro: accepts_nested_attributes_for
The easiest, but least flexible way to do this is to use a macro at the top of the Contact model file. This will create the writer method of pets_attributes=(), and allow us to use the pets_attributes key in our params hash:

```
accepts_nested_attributes_for :pets 
```

We can add to this macro to allow the form to reject any empty fields in the form:

```
accepts_nested_attributes_for :pets, reject_if: proc { |attributes| attributes['name'].blank? || attributes['breed'].blank? }
```

#### Custom writer method: _attributes=()
The more flexible approach is to write a custom writer method in the Contact model.

```
def pets_attributes=(pets_attributes)
	pets_attributes.values.each do |pet_attribute|
			pet = Pet.create(pet_attribute)
			self.pets << pet
	end
end
```

This method allows us to take all of the values that are in the pets_attributes hash within params and use those values to create pets, which are then added to the current Contact’s collection of pets.

### 3. Use form helpers to create a form aligned to the params we want to end up with
Now we are ready to create a complex form that nests values for our pets within our contacts form. This relies heavily on form helpers, which are really just Ruby methods that transform Ruby code into HTML.

#### form_for
The form_for tag automatically detects whether the form should submit a GET or POST request, and can automatically route the request accordingly. The “f” represents the object, and allows us to generate fields based on each of the object's attributes.

*Code snippet using formfor
*

#### fields_for
The fields_for tag is similar to the form_for tag, but we can use it to nest a belongs_to model (pets) within the model that it belongs to (contact). 

*Code snippet using formfields
*

Together, the field names that are generated within these two form tags should match the keys on our params hash that we planned out, if everything is structured correctly.

### 4. Inspect the form in the browser.
By inspecting the form in browser, we can see how the form helpers were able to automatically generate the HTML we needed for our form.

*Side by side of form and HTML generated
*

We can also test out our form to see exactly how the program is structuring our params hash.

*		Image of params hash
*

### 5. Update the controller to accept and process the new params hash
There are a few areas which need to be updated in order to properly create a new contact with associated pets. The new method in the controller needs to be updated to create a few placeholder pets, using the .build method. 
```
	    def new
        @contact = Contact.new
        3.times { @contact.pets.build }
    end
```

Next, you will need to re-visit which params will be allowed in the hash to create a new Contact through mass assignment.  The simplest way to do this is to update the arguments within the private contact_params method.

```
def contact_params
		params.require(:contact).permit(:user_id, :name, :address, :phone, :email, pets_attributes: [:name, :breed])
end
```


*In this series of How To posts, I will be summarizing the key points of essential topics and illustrating them with a simple example. I’ll briefly explain what each piece of code does and how it works. Stay tuned as I add more How To posts in the series each week!*
